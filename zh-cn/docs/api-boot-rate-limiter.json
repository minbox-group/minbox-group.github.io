{
  "filename": "api-boot-rate-limiter.md",
  "__html": "<h1>ApiBoot 实现分布式令牌桶方式限流</h1>\n<p><code>ApiBoot RateLimiter</code>基于拦截器的实现，封装了<code>Google</code>的<code>令牌桶方式</code>的限流实现，可通过注解配置每个接口的流量<code>QPS</code>（每秒允许的流量请求）。</p>\n<blockquote>\n<p>注意：目前不支持分布式系统的流量限制，会在下个版本进行更新添加。</p>\n</blockquote>\n<h2>添加依赖</h2>\n<pre><code class=\"language-xml\">  <span class=\"hljs-comment\">&lt;!--ApiBoot RateLimiter--&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.minbox.framework<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n    <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>api-boot-starter-rate-limiter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p>注意：如果未添加<code>ApiBoot</code>版本依赖，请访问<a href=\"/zh-cn/docs/version-rely.html\">版本依赖</a>查看添加方式。</p>\n</blockquote>\n<h2>相关配置</h2>\n<table>\n<thead>\n<tr>\n<th>配置名称</th>\n<th>默认值</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><code>api.boot.rate-limiter.interceptor-url</code></td>\n<td>/**</td>\n<td>数组类型，可配置多个限流的路径地址</td>\n</tr>\n<tr>\n<td><code>api.boot.rate-limiter.enable-global-qps</code></td>\n<td>false</td>\n<td>是否开启全局限流配置</td>\n</tr>\n<tr>\n<td><code>api.boot.rate-limiter.global-qps</code></td>\n<td>10</td>\n<td>全局限流QPS</td>\n</tr>\n</tbody>\n</table>\n<h2>QPS定义</h2>\n<p>限流注解<code>RateLimiter</code>配置使用如下所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-meta\">@RestController</span>\n<span class=\"hljs-meta\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/resource\"</span>)\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">ResourceSampleController</span> </span>{\n    <span class=\"hljs-comment\">/**\n     * QPS = 10\n     * 配置该接口每秒只允许访问10次\n     *\n     * <span class=\"hljs-doctag\">@return</span>\n     */</span>\n    <span class=\"hljs-meta\">@RequestMapping</span>(value = <span class=\"hljs-string\">\"/\"</span>)\n    <span class=\"hljs-meta\">@RateLimiter</span>(QPS = <span class=\"hljs-number\">10</span>)\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> UserInfo <span class=\"hljs-title\">user</span><span class=\"hljs-params\">()</span> </span>{\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">new</span> UserInfo(<span class=\"hljs-string\">\"admin\"</span>);\n    }\n}\n</code></pre>\n<h2>单服务限流</h2>\n<p>对于单个服务的场景使用限流时，<code>ApiBoot RateLimiter</code>内部使用<code>Google Guava</code>采用令牌桶的方式实现，具体源码实现详见<code>GoogleGuavaRateLimiter</code>类。</p>\n<blockquote>\n<p>引用<code>ApiBoot RateLimiter</code>的项目如果并未添加<code>spring-boot-starter-data-redis</code>依赖，项目中并未初始化<code>RedisTemplate</code>时则会采用<code>Google Guava</code>方式来进行限流。</p>\n</blockquote>\n<h2>分布式服务限流</h2>\n<p>如果你采用微服务、负载均衡的方式进行部署服务时，单服务限流是无法完成预期的效果的，<code>ApiBoot RateLimiter</code>内部集成了<code>Redis</code>方式来自动完成限流，使用<code>Redis</code>后期也利于扩展，如果应用程序过大也可以搭建<code>Redis 集群</code>完成限流。</p>\n<p><code>ApiBoot RateLimiter</code>内部的<code>Redis</code>使用了<code>SpringCloud GateWay</code>官方用的<code>Lua</code>脚本来保证限流的原子性、线程安全性。</p>\n<p>使用<code>Redis</code>方式很简单，只需要在项目中添加<code>Redis</code>依赖后进行配置后<code>ApiBoot RateLimiter</code>就会自动通过<code>RedisTemplate</code>来操作<code>Lua</code>脚本，步骤如下所示：</p>\n<h4>第一步：添加Redis依赖</h4>\n<pre><code class=\"language-xml\"><span class=\"hljs-comment\">&lt;!--Redis--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>spring-boot-starter-data-redis<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<h4>第二步：配置Redis</h4>\n<pre><code class=\"language-yaml\"><span class=\"hljs-attr\">spring:</span>\n  <span class=\"hljs-comment\"># redis 相关配置</span>\n  <span class=\"hljs-attr\">redis:</span>\n    <span class=\"hljs-attr\">password:</span> <span class=\"hljs-number\">123456</span>\n</code></pre>\n<blockquote>\n<p>如果你所使用的<code>Redis</code>有密码，这里需要进行配置，其他配置参数使用默认值。</p>\n</blockquote>\n<h3>测试限流</h3>\n<p>当我们访问被限流的接口时，<code>ApiBoot RateLimiter</code>会自动向<code>Redis</code>写入两条数据，<code>key</code>如下所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-comment\">// redis key list</span>\nqps_rate_limiter.{/test/}.timestamp\nqps_rate_limiter.{/test/}.tokens\n</code></pre>\n<ul>\n<li><code>qps_rate_limiter.{/test/}.timestamp</code>：存放上一次请求的时间戳</li>\n<li><code>qps_rate_limiter.{/test/}.tokens</code>：存放剩余的请求令牌数量</li>\n</ul>\n<p><code>key</code>的格式为<code>qps_rate_limiter.{xxx}.timestamp</code>、<code>qps_rate_limiter.{xxx}.tokens</code>。</p>\n<p>其中<code>xxx</code>为请求接口的路径。</p>\n<p><strong>当然单服务实例也可以使用<code>Redis</code>方式</strong></p>\n<h2>自定义流量溢出响应</h2>\n<p>流量被限制后可以自定义响应的实体来告知请求发起端，方便做一些业务性质的处理，如下所示：</p>\n<pre><code class=\"language-java\"><span class=\"hljs-keyword\">import</span> org.minbox.framework.api.boot.common.model.ApiBootResult;\n<span class=\"hljs-keyword\">import</span> org.minbox.framework.api.boot.plugin.rate.limiter.result.RateLimiterOverFlowResponse;\n<span class=\"hljs-keyword\">import</span> org.springframework.stereotype.Component;\n\n<span class=\"hljs-comment\">/**\n * 自定义流量溢出后响应的实体格式\n *\n * <span class=\"hljs-doctag\">@author</span>：恒宇少年 - 于起宇\n * &lt;p&gt;\n * DateTime：2019-05-25 16:21\n * Blog：https://blog.yuqiyu.com\n * WebSite：http://www.jianshu.com/u/092df3f77bca\n * Gitee：https://gitee.com/hengboy\n * GitHub：https://github.com/hengboy\n */</span>\n<span class=\"hljs-meta\">@Component</span>\n<span class=\"hljs-keyword\">public</span> <span class=\"hljs-class\"><span class=\"hljs-keyword\">class</span> <span class=\"hljs-title\">CustomerResponse</span> <span class=\"hljs-keyword\">implements</span> <span class=\"hljs-title\">RateLimiterOverFlowResponse</span> </span>{\n    <span class=\"hljs-meta\">@Override</span>\n    <span class=\"hljs-function\"><span class=\"hljs-keyword\">public</span> Object <span class=\"hljs-title\">overflow</span><span class=\"hljs-params\">(Object[] methodArgs)</span> </span>{\n        <span class=\"hljs-keyword\">return</span> ApiBootResult.builder().errorCode(<span class=\"hljs-string\">\"REQUEST_OVER_FLOW\"</span>).errorMessage(<span class=\"hljs-string\">\"流量被限制.\"</span>).build();\n    }\n}\n</code></pre>\n<blockquote>\n<p><code>overflow</code>方法可返回任意类型对象。</p>\n</blockquote>\n<h2>配置中心支持</h2>\n<p>为了保证有前瞻性突发流量的处理，<code>ApiBoot RateLimiter</code>支持了外部配置中心，在配置中心修改接口限流<code>QPS</code>后会实时更新到应用程序内。</p>\n<h3>Nacos 配置中心</h3>\n<p>如果你想使用<code>Nacos Config</code>作为<code>ApiBoot RateLimiter</code>的外部<code>QPS</code>配置方式，那么我们需要进行下面的步骤来完成：</p>\n<h4>添加依赖</h4>\n<pre><code class=\"language-xml\"><span class=\"hljs-comment\">&lt;!--Nacos--&gt;</span>\n<span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">dependency</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">groupId</span>&gt;</span>com.alibaba.boot<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">groupId</span>&gt;</span>\n  <span class=\"hljs-tag\">&lt;<span class=\"hljs-name\">artifactId</span>&gt;</span>nacos-config-spring-boot-starter<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">artifactId</span>&gt;</span>\n<span class=\"hljs-tag\">&lt;/<span class=\"hljs-name\">dependency</span>&gt;</span>\n</code></pre>\n<blockquote>\n<p><code>ApiBoot</code>内置了<code>Nacos Starter</code>的版本，这里无需添加版本号。</p>\n</blockquote>\n<h4>配置参数</h4>\n<p>我们添加了<code>Nacos</code>依赖，那需要进行配置<code>Nacos Server</code>的地址，具体<code>Nacos Server</code>怎么安装，可以去看我的博客文章或者直接访问<a href=\"https://nacos.io/zh-cn/docs/quick-start.html\">Nacos 快速开始</a></p>\n<p><code>Nacos在application.yml</code>配置如下所示：</p>\n<pre><code class=\"language-yaml\"><span class=\"hljs-comment\"># nacos config</span>\n<span class=\"hljs-attr\">nacos:</span>\n  <span class=\"hljs-attr\">config:</span>\n    <span class=\"hljs-attr\">server-addr:</span> <span class=\"hljs-number\">127.0</span><span class=\"hljs-number\">.0</span><span class=\"hljs-number\">.1</span><span class=\"hljs-string\">:8848</span>\n</code></pre>\n<p><code>8848</code>是<code>Nacos Server</code>的默认端口号，这里直接配置使用。</p>\n<h4>测试动态修改</h4>\n<p>我们在启动应用程序时，<code>ApiBoot RateLimiter</code>会自动从<code>Nacos</code>读取<code>DATA_ID</code>为<code>apiboot-rate-limiter-config</code>的配置，分组为<code>DEFAULT_GROUP</code>的<code>Properties</code>类型的配置文件，然后<strong>缓存到本地</strong>。</p>\n<p>如果<code>Nacos</code>并没有该配置文件，则在<strong>第一次访问接口时自动创建</strong>。</p>\n<p><img src=\"http://image.yuqiyu.com/apiboot/rate-limiter-nacos-config.png\" alt=\"\"></p>\n<p><code>apiboot-rate-limiter-config</code>配置文件是<code>Properties</code>形式的存储的，那么<code>Key</code>的生成规则则是把请求接口地址的<code>/</code>替换为了<code>.</code>，如下所示：</p>\n<pre><code class=\"language-properties\"><span class=\"hljs-meta\">.resource.</span>=<span class=\"hljs-string\">50</span>\n<span class=\"hljs-meta\">.resource.detail</span>=<span class=\"hljs-string\">10</span>\n</code></pre>\n<p>下面我们来测试修改配置后，<code>ApiBoot RateLimiter</code>是否可以实时生效，将<code>.resource.</code>修改为20后，控制台会打印如下日志信息：</p>\n<pre><code class=\"language-sh\">Update <span class=\"hljs-built_in\">local</span> current RateLimiter configuration is complete，content：{.resource.=20, .resource.detail=10}\n</code></pre>\n<p>当我们再次访问<code>/resource/</code>接口时就会发现限流的<code>QPS</code>一秒内只允许访问<code>20</code>次。</p>\n",
  "link": "/zh-cn/docs/api-boot-rate-limiter.html",
  "meta": {
    "title": "ApiBoot Rate Limiter 使用文档"
  }
}